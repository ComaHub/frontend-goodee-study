<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 1. for of (ES6)
    // 반복 가능한 객체(iterable)의 value를 반복
    // ex. Array, String, NodeList 등

    // for (const element of object) {
    //   code;
    // }

    // object: iterable한 객체
    // element: 객체의 value

    // 1) 배열에 대한 반복
    const fruits = ["Apple", "Banana", "Orange"];

    // for 사용
    for (let i = 0; i < fruits.length; i++) {
      console.log(fruits[i]);
    }

    // for of 사용 => index 값이 필요 없는 경우
    for (const fruit of fruits) {
      console.log(fruit);
    }

    // 2) 문자열에 대한 반복
    const language = "JavaScript";

    for (const s of language) {
      console.log(s);
    }

    // 3) 객체에 대한 반복
    // Object 객체는 iterable이 아님!
    const car = {
      maker: "BMW",
      color: "white",
      year: 2020
    };

    // for (const prop of car) { // TypeError!
    //   console.log(prop);
    // }

    // Object 객체에 대한 반복은 어떻게 구현할까?
    // const keyArr = Object.keys(car);
    for (const key of Object.keys(car)) {
      const value = car[key];
      console.log(value);
    } 

    // (참고) Object.entries(): 객체의 모든 key/value 쌍을 배열로 가져옴
    console.log(Object.entries(car));

    // (참고) 반복 가능한 객체 구분법
    // iterable 객체: Symbol.iterator가 구현된 객체
    // Symbol.iterator 메서드가 있는지 확인
    // ex)
    console.log([1, 2, 3]);
    console.log(new String("abc"));
    
    
    // 2. for in (ES1)
    // (순서 없이) 객체의 key를 반복
    // for (const key in object) {
    //   code;
    // }
    for (const key in car) {
      console.log(car[key]);
    }


    // 3. for of와 for in의 차이
    const list = [4, 5, 6];

    // for in은 key를 반환
    for (const key in list) {
      console.log(key);
      // console.log(typeof key);
    }

    // for of는 value를 반환
    for (const value of list) {
      console.log(value);
      // console.log(typeof value);
    }

    // (참고) 배열에는 for in 루프 사용을 지양
    // 1) 배열에 사용 시 성능이 떨어짐
    // (객체와 함께 사용할 때 최적화되어 있어서 객체 대비 10~100배 정도 느리다.)
    // (반복문의 속도가 대체로 빠른 편이기 때문에 병목 지점에서만 문제가 되긴 하지만 이런 차이를 알고 적절히 사용)
    // 2) 인덱스 순서가 중요한 경우 순서를 보장할 수 없음
    // 배열 값이 예상한 순서대로 액세스 되지 않을 수 있다.
    // 순서가 중요한 경우 for 루프, for of 루프 또는 Array.forEach()를 사용 권장
  </script>
</body>

</html>